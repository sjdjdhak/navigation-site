# å¯¼èˆªç«™é¡¹ç›®ä¼˜åŒ–æŒ‡å—

## æ¦‚è¿°

æœ¬æ–‡æ¡£é’ˆå¯¹å¯¼èˆªç«™é¡¹ç›®ä¸­éœ€è¦ä¼˜åŒ–çš„å››ä¸ªæ ¸å¿ƒæ–¹é¢æä¾›è¯¦ç»†çš„å®æ–½æ–¹æ¡ˆï¼š
1. æ€§èƒ½ä¼˜åŒ–åŠŸèƒ½ï¼ˆæ‡’åŠ è½½ã€è™šæ‹Ÿæ»šåŠ¨ï¼‰
2. å®Œæ•´çš„é”™è¯¯å¤„ç†
3. æµ‹è¯•è¦†ç›–
4. æ–‡æ¡£å®Œå–„

## 1. æ€§èƒ½ä¼˜åŒ–åŠŸèƒ½

### 1.1 æ‡’åŠ è½½ä¼˜åŒ–

#### å½“å‰çŠ¶æ€
- âœ… `OptimizedIcon.vue` å·²å®ç°å›¾ç‰‡æ‡’åŠ è½½
- âš ï¸ ç¼ºå°‘ç»„ä»¶çº§æ‡’åŠ è½½
- âš ï¸ ç¼ºå°‘è·¯ç”±çº§æ‡’åŠ è½½ä¼˜åŒ–

#### éœ€è¦å®æ–½çš„ä¼˜åŒ–

##### 1.1.1 ç»„ä»¶çº§æ‡’åŠ è½½
```typescript
// æ–°å»º src/components/LazyWrapper.vue
<template>
  <div ref="containerRef" class="lazy-wrapper">
    <div v-if="isVisible || forceLoad" class="lazy-content">
      <slot />
    </div>
    <div v-else class="lazy-placeholder" :style="placeholderStyle">
      <div class="skeleton" v-if="showSkeleton">
        <div class="skeleton-title"></div>
        <div class="skeleton-text"></div>
      </div>
      <div v-else class="loading-indicator">
        <el-icon class="is-loading"><Loading /></el-icon>
      </div>
    </div>
  </div>
</template>
```

##### 1.1.2 åˆ†ç±»æ•°æ®æ‡’åŠ è½½
```typescript
// ä¼˜åŒ– src/stores/data.ts ä¸­çš„ loadWebsites æ–¹æ³•
const loadWebsitesLazy = async (categoryId: string) => {
  if (loadedCategories.value.has(categoryId)) {
    return // å·²åŠ è½½ï¼Œç›´æ¥è¿”å›
  }
  
  try {
    loading.value = true
    const websiteData = await import(`@data/${categoryId}.json`)
    const data = websiteData.default
    
    // å¢é‡æ·»åŠ æ•°æ®
    websites.value.push(...data)
    loadedCategories.value.add(categoryId)
  } catch (err) {
    console.error(`Failed to load category ${categoryId}:`, err)
    throw err
  } finally {
    loading.value = false
  }
}
```

### 1.2 è™šæ‹Ÿæ»šåŠ¨å®ç°

#### éœ€è¦åˆ›å»ºçš„æ–‡ä»¶

##### 1.2.1 è™šæ‹Ÿæ»šåŠ¨ç»„ä»¶
```vue
<!-- æ–°å»º src/components/VirtualGrid.vue -->
<template>
  <div ref="containerRef" class="virtual-grid" @scroll="handleScroll">
    <div class="virtual-spacer" :style="{ height: totalHeight + 'px' }">
      <div
        class="virtual-content"
        :style="{
          transform: `translateY(${startOffset}px)`,
          height: visibleHeight + 'px'
        }"
      >
        <div
          v-for="item in visibleItems"
          :key="getItemKey(item)"
          class="virtual-item"
          :style="getItemStyle(item)"
        >
          <slot :item="item" :index="item.index" />
        </div>
      </div>
    </div>
  </div>
</template>
```

##### 1.2.2 ç½‘æ ¼å¡ç‰‡è™šæ‹ŸåŒ–
```typescript
// ä¼˜åŒ– src/components/ResourceGrid.vue
import VirtualGrid from './VirtualGrid.vue'

const useVirtualGrid = (items: Ref<Website[]>) => {
  const containerHeight = ref(600)
  const itemHeight = ref(280) // å¡ç‰‡é«˜åº¦
  const itemsPerRow = ref(3)   // æ¯è¡Œæ˜¾ç¤ºæ•°é‡
  
  const rowCount = computed(() => 
    Math.ceil(items.value.length / itemsPerRow.value)
  )
  
  const getVisibleRange = (scrollTop: number, clientHeight: number) => {
    const startRow = Math.floor(scrollTop / itemHeight.value)
    const endRow = Math.min(
      rowCount.value - 1,
      startRow + Math.ceil(clientHeight / itemHeight.value) + 1
    )
    
    return {
      startIndex: startRow * itemsPerRow.value,
      endIndex: Math.min((endRow + 1) * itemsPerRow.value, items.value.length)
    }
  }
  
  return {
    containerHeight,
    itemHeight,
    itemsPerRow,
    getVisibleRange
  }
}
```

### 1.3 å›¾ç‰‡é¢„åŠ è½½ä¼˜åŒ–

#### å®æ–½æ–¹æ¡ˆ
```typescript
// æ–°å»º src/utils/preloader.ts
export class ImagePreloader {
  private cache = new Map<string, Promise<HTMLImageElement>>()
  private queue: string[] = []
  private concurrent = 3
  private processing = 0

  async preload(urls: string[]): Promise<void> {
    this.queue.push(...urls)
    this.processQueue()
  }

  private async processQueue(): Promise<void> {
    while (this.queue.length > 0 && this.processing < this.concurrent) {
      const url = this.queue.shift()!
      this.processing++
      
      try {
        await this.loadImage(url)
      } catch (error) {
        console.warn(`Failed to preload image: ${url}`, error)
      } finally {
        this.processing--
      }
    }
  }

  private loadImage(url: string): Promise<HTMLImageElement> {
    if (this.cache.has(url)) {
      return this.cache.get(url)!
    }

    const promise = new Promise<HTMLImageElement>((resolve, reject) => {
      const img = new Image()
      img.onload = () => resolve(img)
      img.onerror = reject
      img.src = url
    })

    this.cache.set(url, promise)
    return promise
  }
}
```

## 2. å®Œæ•´çš„é”™è¯¯å¤„ç†

### 2.1 å…¨å±€é”™è¯¯å¤„ç†

#### éœ€è¦åˆ›å»ºçš„æ–‡ä»¶

##### 2.1.1 é”™è¯¯å¤„ç†æœåŠ¡
```typescript
// æ–°å»º src/utils/error-handler.ts
export enum ErrorType {
  NETWORK = 'network',
  DATA = 'data', 
  AUTH = 'auth',
  UNKNOWN = 'unknown'
}

export interface AppError {
  id: string
  type: ErrorType
  message: string
  details?: any
  timestamp: Date
  stack?: string
}

export class ErrorHandler {
  private errors = ref<AppError[]>([])
  private maxErrors = 50

  handleError(error: unknown, context?: string): AppError {
    const appError = this.parseError(error, context)
    this.addError(appError)
    this.logError(appError)
    return appError
  }

  private parseError(error: unknown, context?: string): AppError {
    const id = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    const timestamp = new Date()

    if (error instanceof TypeError && error.message.includes('fetch')) {
      return {
        id,
        type: ErrorType.NETWORK,
        message: 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®',
        details: { originalError: error.message, context },
        timestamp
      }
    }

    if (error instanceof Error) {
      return {
        id,
        type: ErrorType.UNKNOWN,
        message: error.message || 'æœªçŸ¥é”™è¯¯',
        details: { context },
        timestamp,
        stack: error.stack
      }
    }

    return {
      id,
      type: ErrorType.UNKNOWN,
      message: 'å‘ç”Ÿäº†æœªçŸ¥é”™è¯¯',
      details: { originalError: error, context },
      timestamp
    }
  }

  private addError(error: AppError): void {
    this.errors.value.unshift(error)
    if (this.errors.value.length > this.maxErrors) {
      this.errors.value = this.errors.value.slice(0, this.maxErrors)
    }
  }

  private logError(error: AppError): void {
    console.error(`[${error.type.toUpperCase()}] ${error.message}`, {
      id: error.id,
      details: error.details,
      timestamp: error.timestamp,
      stack: error.stack
    })
  }

  getErrors(): Ref<AppError[]> {
    return this.errors
  }

  clearError(id: string): void {
    this.errors.value = this.errors.value.filter(e => e.id !== id)
  }

  clearAllErrors(): void {
    this.errors.value = []
  }
}
```

##### 2.1.2 é”™è¯¯è¾¹ç•Œç»„ä»¶
```vue
<!-- æ–°å»º src/components/ErrorBoundary.vue -->
<template>
  <div class="error-boundary">
    <slot v-if="!hasError" />
    <div v-else class="error-fallback">
      <div class="error-icon">
        <el-icon size="48"><Warning /></el-icon>
      </div>
      <h3>å‡ºç°äº†é”™è¯¯</h3>
      <p>{{ errorMessage }}</p>
      <div class="error-actions">
        <el-button @click="retry" type="primary">é‡è¯•</el-button>
        <el-button @click="reportError" type="default">æŠ¥å‘Šé—®é¢˜</el-button>
      </div>
      <details v-if="showDetails" class="error-details">
        <summary>é”™è¯¯è¯¦æƒ…</summary>
        <pre>{{ errorDetails }}</pre>
      </details>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onErrorCaptured } from 'vue'
import { Warning } from '@element-plus/icons-vue'
import { useErrorHandler } from '@/composables/useErrorHandler'

interface Props {
  fallback?: string
  showDetails?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  fallback: 'åŠ è½½å¤±è´¥',
  showDetails: false
})

const emit = defineEmits<{
  error: [error: Error]
  retry: []
}>()

const { handleError } = useErrorHandler()
const hasError = ref(false)
const errorMessage = ref('')
const errorDetails = ref('')

onErrorCaptured((error: Error) => {
  hasError.value = true
  errorMessage.value = error.message || props.fallback
  errorDetails.value = error.stack || ''
  
  handleError(error, 'ErrorBoundary')
  emit('error', error)
  
  return false // é˜»æ­¢é”™è¯¯ç»§ç»­ä¼ æ’­
})

const retry = () => {
  hasError.value = false
  errorMessage.value = ''
  errorDetails.value = ''
  emit('retry')
}

const reportError = () => {
  // å‘é€é”™è¯¯æŠ¥å‘Šçš„é€»è¾‘
  console.log('æŠ¥å‘Šé”™è¯¯:', { errorMessage: errorMessage.value, errorDetails: errorDetails.value })
}
</script>
```

### 2.2 ç½‘ç»œè¯·æ±‚é”™è¯¯å¤„ç†

#### ä¼˜åŒ–ç½‘ç»œè¯·æ±‚
```typescript
// æ–°å»º src/utils/request.ts
export interface RequestConfig {
  timeout?: number
  retries?: number
  retryDelay?: number
}

export class NetworkError extends Error {
  constructor(
    message: string,
    public status?: number,
    public response?: Response
  ) {
    super(message)
    this.name = 'NetworkError'
  }
}

export async function request<T>(
  url: string,
  options: RequestInit = {},
  config: RequestConfig = {}
): Promise<T> {
  const {
    timeout = 10000,
    retries = 3,
    retryDelay = 1000
  } = config

  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), timeout)

  let lastError: Error

  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      })

      clearTimeout(timeoutId)

      if (!response.ok) {
        throw new NetworkError(
          `HTTP ${response.status}: ${response.statusText}`,
          response.status,
          response
        )
      }

      return await response.json()
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error))
      
      if (attempt === retries) {
        break
      }

      // æŒ‡æ•°é€€é¿é‡è¯•
      const delay = retryDelay * Math.pow(2, attempt)
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }

  clearTimeout(timeoutId)
  throw lastError!
}
```

### 2.3 çŠ¶æ€ç®¡ç†é”™è¯¯å¤„ç†

#### ä¼˜åŒ–æ•°æ®å­˜å‚¨
```typescript
// ä¼˜åŒ– src/stores/data.ts
export const useDataStore = defineStore('data', () => {
  const { handleError, clearError } = useErrorHandler()
  
  const loadCategories = async () => {
    try {
      loading.value = true
      clearError() // æ¸…é™¤ä¹‹å‰çš„é”™è¯¯
      
      const categoriesData = await import('@data/categories.json')
      const rawData = categoriesData.default
      
      if (Array.isArray(rawData)) {
        rawCategoriesData.value = rawData
      } else if (rawData.categories) {
        categoryConfig.value = rawData as CategoryConfig
      } else {
        throw new Error('Invalid categories data format')
      }
    } catch (err) {
      const appError = handleError(err, 'loadCategories')
      error.value = appError.message
      
      // æä¾›é™çº§æ–¹æ¡ˆ
      if (categoryConfig.value === null && rawCategoriesData.value.length === 0) {
        // ä½¿ç”¨ç©ºæ•°æ®ä½œä¸ºé™çº§æ–¹æ¡ˆ
        rawCategoriesData.value = []
        console.warn('ä½¿ç”¨ç©ºåˆ†ç±»æ•°æ®ä½œä¸ºé™çº§æ–¹æ¡ˆ')
      }
    } finally {
      loading.value = false
    }
  }

  const loadWebsitesWithRetry = async (categoryId?: string, maxRetries = 3) => {
    let retryCount = 0
    
    while (retryCount <= maxRetries) {
      try {
        await loadWebsites(categoryId)
        return // æˆåŠŸåˆ™é€€å‡º
      } catch (error) {
        retryCount++
        
        if (retryCount > maxRetries) {
          handleError(error, `loadWebsites failed after ${maxRetries} retries`)
          throw error
        }
        
        // ç­‰å¾…åé‡è¯•
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount))
      }
    }
  }
})
```

## 3. æµ‹è¯•è¦†ç›–

### 3.1 å•å…ƒæµ‹è¯•æ¡†æ¶æ­å»º

#### éœ€è¦å®‰è£…çš„ä¾èµ–
```json
{
  "devDependencies": {
    "@vue/test-utils": "^2.4.0",
    "vitest": "^1.0.0",
    "jsdom": "^23.0.0",
    "@testing-library/vue": "^8.0.0",
    "@testing-library/jest-dom": "^6.0.0",
    "happy-dom": "^12.0.0"
  }
}
```

#### Vitesté…ç½®
```typescript
// æ›´æ–° vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  // ... ç°æœ‰é…ç½®
  test: {
    globals: true,
    environment: 'happy-dom',
    setupFiles: ['./src/test/setup.ts'],
    include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    exclude: ['node_modules', 'dist', '.nuxt']
  }
})
```

### 3.2 æµ‹è¯•ç”¨ä¾‹å®ç°

#### 3.2.1 ç»„ä»¶æµ‹è¯•
```typescript
// æ–°å»º src/test/components/ResourceGrid.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import ResourceGrid from '@/components/ResourceGrid.vue'
import type { Website } from '@/types'

const mockWebsites: Website[] = [
  {
    id: 'test-1',
    title: 'Test Website 1',
    description: 'Test description 1',
    url: 'https://test1.com',
    domain: 'test1.com',
    icon: '',
    tags: ['test', 'mock'],
    categoryPath: ['test-category'],
    featured: true,
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z'
  }
]

describe('ResourceGrid', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should render websites correctly', () => {
    const wrapper = mount(ResourceGrid, {
      props: {
        websites: mockWebsites
      }
    })

    expect(wrapper.find('.resource-grid').exists()).toBe(true)
    expect(wrapper.find('.site-card').exists()).toBe(true)
    expect(wrapper.text()).toContain('Test Website 1')
  })

  it('should show loading state', () => {
    const wrapper = mount(ResourceGrid, {
      props: {
        websites: [],
        loading: true
      }
    })

    expect(wrapper.find('.loading-state').exists()).toBe(true)
    expect(wrapper.find('.loading-spinner').exists()).toBe(true)
  })

  it('should show empty state when no websites', () => {
    const wrapper = mount(ResourceGrid, {
      props: {
        websites: []
      }
    })

    expect(wrapper.find('.empty-state').exists()).toBe(true)
  })

  it('should emit website click event', async () => {
    const wrapper = mount(ResourceGrid, {
      props: {
        websites: mockWebsites
      }
    })

    await wrapper.find('.site-card').trigger('click')
    expect(wrapper.emitted('website-click')).toBeTruthy()
    expect(wrapper.emitted('website-click')![0]).toEqual([mockWebsites[0]])
  })
})
```

#### 3.2.2 Storeæµ‹è¯•
```typescript
// æ–°å»º src/test/stores/data.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useDataStore } from '@/stores/data'

// Mockæ•°æ®å¯¼å…¥
vi.mock('@data/categories.json', () => ({
  default: {
    version: '1.0',
    categories: [
      {
        id: 'test-category',
        name: 'Test Category',
        icon: 'fas fa-test',
        description: 'Test category description',
        order: 0,
        expanded: false
      }
    ]
  }
}))

vi.mock('@data/test-category.json', () => ({
  default: [
    {
      id: 'test-site',
      title: 'Test Site',
      description: 'Test site description',
      url: 'https://test.com',
      domain: 'test.com',
      tags: ['test'],
      categoryPath: ['test-category'],
      featured: false,
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z'
    }
  ]
}))

describe('Data Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('should initialize categories correctly', async () => {
    const dataStore = useDataStore()
    await dataStore.loadCategories()

    expect(dataStore.categories).toHaveLength(1)
    expect(dataStore.categories[0].id).toBe('test-category')
    expect(dataStore.categories[0].name).toBe('Test Category')
  })

  it('should load websites correctly', async () => {
    const dataStore = useDataStore()
    await dataStore.loadCategories()
    await dataStore.loadWebsites()

    expect(dataStore.websites).toHaveLength(1)
    expect(dataStore.websites[0].id).toBe('test-site')
    expect(dataStore.websites[0].title).toBe('Test Site')
  })

  it('should search websites correctly', async () => {
    const dataStore = useDataStore()
    await dataStore.initialize()

    const result = dataStore.searchWebsites('Test')
    expect(result.websites).toHaveLength(1)
    expect(result.total).toBe(1)
    expect(result.query).toBe('Test')
  })

  it('should handle search with category filter', async () => {
    const dataStore = useDataStore()
    await dataStore.initialize()

    const result = dataStore.searchWebsites('', ['test-category'])
    expect(result.websites).toHaveLength(1)
    expect(result.websites[0].categoryPath).toContain('test-category')
  })
})
```

#### 3.2.3 å·¥å…·å‡½æ•°æµ‹è¯•
```typescript
// æ–°å»º src/test/utils/favicon-helper.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { getFaviconUrl, preloadFavicon } from '@/utils/favicon-helper'

// Mock fetch
global.fetch = vi.fn()

describe('Favicon Helper', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    localStorage.clear()
  })

  it('should return cached favicon URL', async () => {
    const mockFetch = fetch as unknown as vi.MockedFunction<typeof fetch>
    mockFetch.mockResolvedValueOnce(
      new Response('', { status: 200, headers: { 'content-type': 'image/png' } })
    )

    const url1 = await getFaviconUrl('example.com')
    const url2 = await getFaviconUrl('example.com')

    expect(url1).toBe(url2)
    expect(mockFetch).toHaveBeenCalledTimes(1) // ç¬¬äºŒæ¬¡è°ƒç”¨ä½¿ç”¨ç¼“å­˜
  })

  it('should handle failed favicon requests', async () => {
    const mockFetch = fetch as unknown as vi.MockedFunction<typeof fetch>
    mockFetch.mockRejectedValue(new Error('Network error'))

    const url = await getFaviconUrl('nonexistent.com')
    expect(url).toBe('/assets/default-favicon.svg')
  })

  it('should preload favicon without blocking', async () => {
    const mockFetch = fetch as unknown as vi.MockedFunction<typeof fetch>
    mockFetch.mockResolvedValueOnce(
      new Response('', { status: 200, headers: { 'content-type': 'image/png' } })
    )

    const promise = preloadFavicon('example.com')
    expect(promise).toBeInstanceOf(Promise)
    
    // ä¸åº”è¯¥æŠ›å‡ºé”™è¯¯
    await expect(promise).resolves.toBeUndefined()
  })
})
```

### 3.3 E2Eæµ‹è¯•

#### 3.3.1 Playwrighté…ç½®
```typescript
// æ–°å»º playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './e2e',
  timeout: 30 * 1000,
  expect: {
    timeout: 5000
  },
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3003',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] }
    }
  ],
  webServer: {
    command: 'npm run dev',
    port: 3003,
    reuseExistingServer: !process.env.CI
  }
})
```

#### 3.3.2 E2Eæµ‹è¯•ç”¨ä¾‹
```typescript
// æ–°å»º e2e/navigation.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Navigation Site', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/')
  })

  test('should display homepage correctly', async ({ page }) => {
    await expect(page).toHaveTitle(/å¯¼èˆªç«™/)
    await expect(page.locator('.main-content')).toBeVisible()
    await expect(page.locator('.search-section')).toBeVisible()
  })

  test('should open sidebar when menu button clicked', async ({ page }) => {
    const menuButton = page.locator('[data-testid="menu-button"]')
    await menuButton.click()
    
    await expect(page.locator('.sidebar')).toHaveClass(/open/)
  })

  test('should search websites', async ({ page }) => {
    const searchInput = page.locator('[data-testid="search-input"]')
    await searchInput.fill('è®¾è®¡')
    await searchInput.press('Enter')
    
    await expect(page.locator('.resource-grid')).toBeVisible()
    await expect(page.locator('.site-card')).toHaveCount(1) // è‡³å°‘æœ‰ä¸€ä¸ªç»“æœ
  })

  test('should navigate between categories', async ({ page }) => {
    // æ‰“å¼€ä¾§è¾¹æ 
    await page.locator('[data-testid="menu-button"]').click()
    
    // ç‚¹å‡»åˆ†ç±»
    const categoryItem = page.locator('[data-testid="category-item"]').first()
    await categoryItem.click()
    
    // éªŒè¯é¡µé¢è·³è½¬
    await expect(page.url()).toContain('/category/')
    await expect(page.locator('.category-header')).toBeVisible()
  })

  test('should toggle theme', async ({ page }) => {
    const themeButton = page.locator('[data-testid="theme-toggle"]')
    await themeButton.click()
    
    await expect(page.locator('body')).toHaveClass(/dark-theme/)
  })

  test('should handle responsive design', async ({ page }) => {
    // æµ‹è¯•ç§»åŠ¨ç«¯è§†å£
    await page.setViewportSize({ width: 375, height: 667 })
    
    await expect(page.locator('.sidebar')).toHaveClass(/mobile/)
    await expect(page.locator('.cards-grid')).toHaveCSS('grid-template-columns', '1fr')
  })
})
```

## 4. æ–‡æ¡£å®Œå–„

### 4.1 APIæ–‡æ¡£

#### éœ€è¦åˆ›å»ºçš„æ–‡æ¡£

##### 4.1.1 ç»„ä»¶æ–‡æ¡£
```markdown
<!-- æ–°å»º docs/components/README.md -->
# ç»„ä»¶æ–‡æ¡£

## ResourceGrid èµ„æºç½‘æ ¼ç»„ä»¶

### ç”¨é€”
ç”¨äºå±•ç¤ºç½‘ç«™èµ„æºå¡ç‰‡çš„ç½‘æ ¼å¸ƒå±€ç»„ä»¶ï¼Œæ”¯æŒå“åº”å¼è®¾è®¡å’Œäº¤äº’æ•ˆæœã€‚

### Props
| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|------|--------|------|
| websites | Website[] | [] | è¦æ˜¾ç¤ºçš„ç½‘ç«™åˆ—è¡¨ |
| loading | boolean | false | æ˜¯å¦æ˜¾ç¤ºåŠ è½½çŠ¶æ€ |
| columns | number | 3 | ç½‘æ ¼åˆ—æ•° |

### Events
| äº‹ä»¶å | å‚æ•° | è¯´æ˜ |
|--------|------|------|
| website-click | website: Website | ç‚¹å‡»ç½‘ç«™å¡ç‰‡æ—¶è§¦å‘ |
| load-more | - | æ»šåŠ¨åˆ°åº•éƒ¨æ—¶è§¦å‘ |

### ä½¿ç”¨ç¤ºä¾‹
\`\`\`vue
<template>
  <ResourceGrid
    :websites="websites"
    :loading="loading"
    @website-click="handleWebsiteClick"
  />
</template>
\`\`\`

## OptimizedIcon ä¼˜åŒ–å›¾æ ‡ç»„ä»¶

### ç”¨é€”
æ™ºèƒ½è·å–å’Œæ˜¾ç¤ºç½‘ç«™å›¾æ ‡ï¼Œæ”¯æŒå¤šæºè·å–ã€é”™è¯¯å¤„ç†å’Œæ‡’åŠ è½½ã€‚

### Props
| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|------|--------|------|
| domain | string | '' | ç½‘ç«™åŸŸå |
| url | string | '' | ç½‘ç«™URL |
| size | number | 32 | å›¾æ ‡å°ºå¯¸ |
| lazy | boolean | false | æ˜¯å¦å¯ç”¨æ‡’åŠ è½½ |

### æ–¹æ³•
| æ–¹æ³•å | å‚æ•° | è¯´æ˜ |
|--------|------|------|
| refresh | - | é‡æ–°è·å–å›¾æ ‡ |
| retry | - | é‡è¯•è·å–å›¾æ ‡ |
```

##### 4.1.2 Storeæ–‡æ¡£
```markdown
<!-- æ–°å»º docs/stores/README.md -->
# çŠ¶æ€ç®¡ç†æ–‡æ¡£

## useDataStore æ•°æ®å­˜å‚¨

### ç”¨é€”
ç®¡ç†å¯¼èˆªç«™çš„åˆ†ç±»å’Œç½‘ç«™æ•°æ®ï¼Œæä¾›æ•°æ®è·å–ã€æœç´¢ã€å¢åˆ æ”¹æŸ¥ç­‰åŠŸèƒ½ã€‚

### çŠ¶æ€
| å±æ€§å | ç±»å‹ | è¯´æ˜ |
|--------|------|------|
| websites | Website[] | ç½‘ç«™æ•°æ®åˆ—è¡¨ |
| categories | Category[] | åˆ†ç±»æ•°æ® |
| loading | boolean | åŠ è½½çŠ¶æ€ |
| error | string \| null | é”™è¯¯ä¿¡æ¯ |

### è®¡ç®—å±æ€§
| å±æ€§å | ç±»å‹ | è¯´æ˜ |
|--------|------|------|
| featuredWebsites | Website[] | æ¨èç½‘ç«™åˆ—è¡¨ |
| allTags | string[] | æ‰€æœ‰æ ‡ç­¾åˆ—è¡¨ |
| toolCounts | Record<string, number> | åˆ†ç±»è®¡æ•° |

### æ–¹æ³•
| æ–¹æ³•å | å‚æ•° | è¿”å›å€¼ | è¯´æ˜ |
|--------|------|--------|------|
| initialize | - | Promise<void> | åˆå§‹åŒ–æ•°æ® |
| loadCategories | - | Promise<void> | åŠ è½½åˆ†ç±»æ•°æ® |
| loadWebsites | categoryId?: string | Promise<void> | åŠ è½½ç½‘ç«™æ•°æ® |
| searchWebsites | query: string, categoryPath?: string[] | SearchResult | æœç´¢ç½‘ç«™ |

### ä½¿ç”¨ç¤ºä¾‹
\`\`\`typescript
import { useDataStore } from '@/stores/data'

const dataStore = useDataStore()

// åˆå§‹åŒ–æ•°æ®
await dataStore.initialize()

// æœç´¢ç½‘ç«™
const result = dataStore.searchWebsites('è®¾è®¡å·¥å…·')
console.log(result.websites)
\`\`\`
```

### 4.2 å¼€å‘æ–‡æ¡£

#### 4.2.1 å¼€å‘æŒ‡å—
```markdown
<!-- æ–°å»º docs/DEVELOPMENT.md -->
# å¼€å‘æŒ‡å—

## ç¯å¢ƒè¦æ±‚
- Node.js 18+
- npm 9+
- ç°ä»£æµè§ˆå™¨ï¼ˆæ”¯æŒES2020+ï¼‰

## å¿«é€Ÿå¼€å§‹

### 1. å®‰è£…ä¾èµ–
\`\`\`bash
cd frontend
npm install
\`\`\`

### 2. å¯åŠ¨å¼€å‘æœåŠ¡å™¨
\`\`\`bash
npm run dev
\`\`\`

### 3. æ„å»ºç”Ÿäº§ç‰ˆæœ¬
\`\`\`bash
npm run build
\`\`\`

### 4. è¿è¡Œæµ‹è¯•
\`\`\`bash
# å•å…ƒæµ‹è¯•
npm run test

# E2Eæµ‹è¯•
npm run test:e2e

# æµ‹è¯•è¦†ç›–ç‡
npm run test:coverage
\`\`\`

## é¡¹ç›®ç»“æ„
\`\`\`
frontend/src/
â”œâ”€â”€ components/          # Vueç»„ä»¶
â”‚   â”œâ”€â”€ layout/         # å¸ƒå±€ç»„ä»¶
â”‚   â”œâ”€â”€ common/         # é€šç”¨ç»„ä»¶
â”‚   â””â”€â”€ business/       # ä¸šåŠ¡ç»„ä»¶
â”œâ”€â”€ views/              # é¡µé¢ç»„ä»¶
â”œâ”€â”€ stores/             # PiniaçŠ¶æ€ç®¡ç†
â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•°
â”œâ”€â”€ types/              # TypeScriptç±»å‹å®šä¹‰
â”œâ”€â”€ assets/             # é™æ€èµ„æº
â””â”€â”€ test/               # æµ‹è¯•æ–‡ä»¶
\`\`\`

## å¼€å‘è§„èŒƒ

### ä»£ç é£æ ¼
- ä½¿ç”¨ TypeScript
- éµå¾ª Vue 3 Composition API
- ä½¿ç”¨ ESLint + Prettier
- ç»„ä»¶å‘½åä½¿ç”¨ PascalCase
- æ–‡ä»¶å‘½åä½¿ç”¨ kebab-case

### Gitæäº¤è§„èŒƒ
\`\`\`
feat: æ–°åŠŸèƒ½
fix: ä¿®å¤bug
docs: æ–‡æ¡£æ›´æ–°
style: ä»£ç æ ¼å¼è°ƒæ•´
refactor: ä»£ç é‡æ„
test: æµ‹è¯•ç›¸å…³
chore: æ„å»º/å·¥å…·ç›¸å…³
\`\`\`

### ç»„ä»¶å¼€å‘è§„èŒƒ
1. ä½¿ç”¨ `<script setup>` è¯­æ³•
2. å®šä¹‰æ¸…æ™°çš„ Props å’Œ Emits æ¥å£
3. æ·»åŠ å¿…è¦çš„ç±»å‹å®šä¹‰
4. ç¼–å†™å•å…ƒæµ‹è¯•
5. æ·»åŠ æ–‡æ¡£æ³¨é‡Š
```

#### 4.2.2 éƒ¨ç½²æ–‡æ¡£
```markdown
<!-- æ–°å»º docs/DEPLOYMENT.md -->
# éƒ¨ç½²æŒ‡å—

## Verceléƒ¨ç½²ï¼ˆæ¨èï¼‰

### 1. è¿æ¥GitHubä»“åº“
1. ç™»å½• [Vercel](https://vercel.com)
2. ç‚¹å‡» "New Project"
3. å¯¼å…¥GitHubä»“åº“

### 2. é…ç½®æ„å»ºè®¾ç½®
- Framework Preset: Other
- Root Directory: `frontend`
- Build Command: `npm run build`
- Output Directory: `dist`

### 3. ç¯å¢ƒå˜é‡
\`\`\`env
VERCEL=1
NODE_ENV=production
\`\`\`

## GitHub Pageséƒ¨ç½²

### 1. é…ç½®GitHub Actions
\`\`\`yaml
# .github/workflows/deploy.yml
name: Deploy to GitHub Pages

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        run: |
          cd frontend
          npm ci
      
      - name: Build
        run: |
          cd frontend
          npm run build
      
      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: \${{ secrets.GITHUB_TOKEN }}
          publish_dir: frontend/dist
\`\`\`

### 2. é…ç½®ä»“åº“è®¾ç½®
1. è¿›å…¥ä»“åº“ Settings > Pages
2. Source é€‰æ‹© "GitHub Actions"
3. ç­‰å¾…éƒ¨ç½²å®Œæˆ

## è‡ªå®šä¹‰éƒ¨ç½²

### 1. æ„å»ºé¡¹ç›®
\`\`\`bash
cd frontend
npm install
npm run build
\`\`\`

### 2. é…ç½®WebæœåŠ¡å™¨
ä»¥Nginxä¸ºä¾‹ï¼š
\`\`\`nginx
server {
    listen 80;
    server_name your-domain.com;
    root /path/to/frontend/dist;
    index index.html;
    
    location / {
        try_files \$uri \$uri/ /index.html;
    }
    
    location /assets {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
\`\`\`
```

### 4.3 ç”¨æˆ·æ–‡æ¡£

#### 4.3.1 ç”¨æˆ·æ‰‹å†Œ
```markdown
<!-- æ›´æ–° README.md -->
# å¯¼èˆªç«™é¡¹ç›®

> ä¸€ä¸ªç°ä»£åŒ–çš„ä¸ªäººå·¥å…·é›†å¯¼èˆªç«™ï¼Œå¸®åŠ©æ‚¨é«˜æ•ˆç®¡ç†å’Œå‘ç°ä¼˜è´¨ç½‘ç«™èµ„æºã€‚

## âœ¨ ç‰¹æ€§

- ğŸ¨ **ç°ä»£è®¾è®¡** - åŸºäº Fluent Design çš„ä¼˜é›…ç•Œé¢
- ğŸ“± **å“åº”å¼** - å®Œç¾é€‚é…æ¡Œé¢ç«¯å’Œç§»åŠ¨ç«¯
- ğŸ” **æ™ºèƒ½æœç´¢** - æ”¯æŒæ ‡é¢˜ã€æè¿°ã€æ ‡ç­¾å¤šç»´åº¦æœç´¢
- ğŸ“ **åˆ†ç±»ç®¡ç†** - æ— é™å±‚çº§çš„åˆ†ç±»ç»“æ„
- ğŸŒ“ **ä¸»é¢˜åˆ‡æ¢** - æ˜æš—ä¸»é¢˜è‡ªç”±åˆ‡æ¢
- âš¡ **æ€§èƒ½ä¼˜åŒ–** - æ‡’åŠ è½½ã€è™šæ‹Ÿæ»šåŠ¨ã€å›¾ç‰‡ä¼˜åŒ–
- ğŸ›¡ï¸ **é”™è¯¯å¤„ç†** - å®Œå–„çš„é”™è¯¯è¾¹ç•Œå’Œé™çº§æ–¹æ¡ˆ

## ğŸš€ å¿«é€Ÿå¼€å§‹

### åœ¨çº¿ä½“éªŒ
è®¿é—® [æ¼”ç¤ºåœ°å€](https://your-demo-site.com) ç«‹å³ä½“éªŒ

### æœ¬åœ°è¿è¡Œ
\`\`\`bash
# å…‹éš†é¡¹ç›®
git clone https://github.com/your-username/navigation-site.git

# å®‰è£…ä¾èµ–
cd navigation-site/frontend
npm install

# å¯åŠ¨å¼€å‘æœåŠ¡å™¨
npm run dev
\`\`\`

## ğŸ“– ä½¿ç”¨æŒ‡å—

### åŸºæœ¬æ“ä½œ
1. **æµè§ˆåˆ†ç±»** - ç‚¹å‡»å·¦ä¾§èœå•æŒ‰é’®æ‰“å¼€åˆ†ç±»å¯¼èˆª
2. **æœç´¢ç½‘ç«™** - åœ¨é¡¶éƒ¨æœç´¢æ¡†è¾“å…¥å…³é”®è¯
3. **åˆ‡æ¢ä¸»é¢˜** - ç‚¹å‡»å³ä¸Šè§’ä¸»é¢˜æŒ‰é’®
4. **æŸ¥çœ‹è¯¦æƒ…** - ç‚¹å‡»ç½‘ç«™å¡ç‰‡æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯

### é«˜çº§åŠŸèƒ½
- **å¿«æ·é”®æ”¯æŒ** - `Ctrl/Cmd + K` å¿«é€Ÿæœç´¢
- **æ”¶è—åŠŸèƒ½** - æ”¶è—å¸¸ç”¨ç½‘ç«™ï¼ˆå¼€å‘ä¸­ï¼‰
- **å†å²è®°å½•** - æŸ¥çœ‹æœ€è¿‘è®¿é—®çš„ç½‘ç«™ï¼ˆå¼€å‘ä¸­ï¼‰

## ğŸ”§ åå°ç®¡ç†

### è®¿é—®åå°
è®¿é—® `/admin` è·¯å¾„è¿›å…¥åå°ç®¡ç†ç³»ç»Ÿ

### ç®¡ç†åŠŸèƒ½
- ç½‘ç«™ä¿¡æ¯çš„å¢åˆ æ”¹æŸ¥
- åˆ†ç±»ç»“æ„ç®¡ç†
- æ•°æ®å¯¼å…¥å¯¼å‡º
- ç³»ç»Ÿè®¾ç½®é…ç½®

è¯¦ç»†è¯´æ˜è¯·æŸ¥çœ‹ [åå°ç®¡ç†æ–‡æ¡£](docs/admin/README.md)

## ğŸ“Š æŠ€æœ¯æ ˆ

- **å‰ç«¯æ¡†æ¶**: Vue 3 + TypeScript
- **UIç»„ä»¶**: Element Plus
- **çŠ¶æ€ç®¡ç†**: Pinia
- **æ„å»ºå·¥å…·**: Vite
- **æ ·å¼å¤„ç†**: SCSS
- **æµ‹è¯•æ¡†æ¶**: Vitest + Playwright
- **éƒ¨ç½²å¹³å°**: Vercel / GitHub Pages

## ğŸ¤ è´¡çŒ®æŒ‡å—

æˆ‘ä»¬æ¬¢è¿ä»»ä½•å½¢å¼çš„è´¡çŒ®ï¼è¯·æŸ¥çœ‹ [è´¡çŒ®æŒ‡å—](CONTRIBUTING.md) äº†è§£è¯¦æƒ…ã€‚

### å¼€å‘æµç¨‹
1. Fork æœ¬ä»“åº“
2. åˆ›å»ºç‰¹æ€§åˆ†æ”¯ (`git checkout -b feature/AmazingFeature`)
3. æäº¤æ›´æ”¹ (`git commit -m 'Add some AmazingFeature'`)
4. æ¨é€åˆ°åˆ†æ”¯ (`git push origin feature/AmazingFeature`)
5. æ‰“å¼€ Pull Request

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®åŸºäº MIT è®¸å¯è¯å¼€æºã€‚è¯¦æƒ…è¯·æŸ¥çœ‹ [LICENSE](LICENSE) æ–‡ä»¶ã€‚

## ğŸ™ è‡´è°¢

æ„Ÿè°¢æ‰€æœ‰è´¡çŒ®è€…çš„è¾›å‹¤ä»˜å‡ºï¼
```

## æ€»ç»“

è¿™ä»½ä¼˜åŒ–æŒ‡å—æ¶µç›–äº†é¡¹ç›®éœ€è¦æ”¹è¿›çš„å››ä¸ªæ ¸å¿ƒæ–¹é¢ï¼š

1. **æ€§èƒ½ä¼˜åŒ–** - é€šè¿‡æ‡’åŠ è½½ã€è™šæ‹Ÿæ»šåŠ¨ã€å›¾ç‰‡é¢„åŠ è½½ç­‰æŠ€æœ¯æå‡ç”¨æˆ·ä½“éªŒ
2. **é”™è¯¯å¤„ç†** - å»ºç«‹å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œæé«˜åº”ç”¨çš„å¥å£®æ€§
3. **æµ‹è¯•è¦†ç›–** - æ­å»ºå®Œæ•´çš„æµ‹è¯•ä½“ç³»ï¼Œç¡®ä¿ä»£ç è´¨é‡å’Œç¨³å®šæ€§
4. **æ–‡æ¡£å®Œå–„** - æä¾›è¯¦å°½çš„æ–‡æ¡£ï¼Œé™ä½å¼€å‘å’Œä½¿ç”¨é—¨æ§›

æŒ‰ç…§è¿™ä¸ªæŒ‡å—é€æ­¥å®æ–½ï¼Œå¯ä»¥æ˜¾è‘—æå‡é¡¹ç›®çš„è´¨é‡å’Œå¯ç»´æŠ¤æ€§ã€‚å»ºè®®æŒ‰ä¼˜å…ˆçº§åˆ†é˜¶æ®µå®æ–½ï¼š

**ç¬¬ä¸€é˜¶æ®µï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰**ï¼š
- å®ç°é”™è¯¯è¾¹ç•Œå’ŒåŸºç¡€é”™è¯¯å¤„ç†
- æ·»åŠ æ ¸å¿ƒç»„ä»¶çš„å•å…ƒæµ‹è¯•
- å®Œå–„READMEå’Œå¼€å‘æ–‡æ¡£

**ç¬¬äºŒé˜¶æ®µï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰**ï¼š
- å®ç°å›¾ç‰‡æ‡’åŠ è½½ä¼˜åŒ–
- æ·»åŠ E2Eæµ‹è¯•
- å®Œå–„APIæ–‡æ¡£

**ç¬¬ä¸‰é˜¶æ®µï¼ˆä½ä¼˜å…ˆçº§ï¼‰**ï¼š
- å®ç°è™šæ‹Ÿæ»šåŠ¨
- æ·»åŠ æ€§èƒ½ç›‘æ§
- å®Œå–„ç”¨æˆ·æ‰‹å†Œ 